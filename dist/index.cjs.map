{"version":3,"sources":["../src/index.ts","../src/ephemeris.ts","../src/utils.ts","../src/acg.ts","../src/parans.ts","../src/localSpace.ts","../src/relocation.ts","../src/analyze.ts","../src/schema.ts"],"sourcesContent":["export * from './types';\nexport { computeACG } from './acg';\nexport { computeParans } from './parans';\nexport { computeLocalSpace } from './localSpace';\nexport { computeRelocationChart } from './relocation';\nexport { analyzeLocation } from './analyze';\nexport { initEphemeris } from './ephemeris';\nexport * from './schema';\n","import swe from 'swisseph';\nimport { DateTime } from 'luxon';\nimport { normalizeDeg, normalizeHour } from './utils';\nimport type { Body, BodyPosition, CalculationOptions, Location } from './types';\n\nconst fortuneCode = (swe as any).SE_PART_FORTUNE ?? (swe as any).SE_PFUND ?? swe.SE_MEAN_NODE;\n\nconst planetMap: Record<Exclude<Body, { asteroid: number; name?: string }>, number> = {\n  sun: swe.SE_SUN,\n  moon: swe.SE_MOON,\n  mercury: swe.SE_MERCURY,\n  venus: swe.SE_VENUS,\n  mars: swe.SE_MARS,\n  jupiter: swe.SE_JUPITER,\n  saturn: swe.SE_SATURN,\n  uranus: swe.SE_URANUS,\n  neptune: swe.SE_NEPTUNE,\n  pluto: swe.SE_PLUTO,\n  true_node: swe.SE_TRUE_NODE,\n  mean_node: swe.SE_MEAN_NODE,\n  chiron: swe.SE_CHIRON,\n  fortune: fortuneCode,\n};\n\nexport type EphemerisConfig = {\n  ephemerisPath?: string;\n  useTopocentric?: boolean;\n};\n\nconst positionCache = new Map<string, BodyPosition>();\n\nexport function initEphemeris(config?: EphemerisConfig) {\n  if (config?.ephemerisPath) {\n    swe.swe_set_ephe_path(config.ephemerisPath);\n  }\n}\n\nfunction buildFlags(opts: CalculationOptions, location?: Location): number {\n  let flags = swe.SEFLG_SPEED;\n  if (opts.moonParallax) flags |= swe.SEFLG_TRUEPOS; // true position for Moon\n  if (opts.system === 'sidereal') {\n    flags |= swe.SEFLG_SIDEREAL;\n    const aya = opts.ayanamsa ?? 'lahiri';\n    const ayaId = ayanamsaToConst(aya);\n    swe.swe_set_sid_mode(ayaId, 0, 0);\n  }\n  if (location && typeof location.lat === 'number' && typeof location.lon === 'number') {\n    flags |= swe.SEFLG_TOPOCTR;\n    swe.swe_set_topo(location.lon, location.lat, location.alt ?? 0);\n  }\n  return flags;\n}\n\nfunction ayanamsaToConst(aya: CalculationOptions['ayanamsa']): number {\n  switch (aya) {\n    case 'lahiri':\n      return swe.SE_SIDM_LAHIRI;\n    case 'krishnamurti':\n      return swe.SE_SIDM_KRISHNAMURTI;\n    case 'raman':\n      return swe.SE_SIDM_RAMAN;\n    case 'fagan_bradley':\n      return swe.SE_SIDM_FAGAN_BRADLEY;\n    case 'yukteshwar':\n      return swe.SE_SIDM_YUKTESHWAR;\n    case 'true_citra':\n      return swe.SE_SIDM_TRUE_CITRA;\n    case 'user':\n      return swe.SE_SIDM_USER;\n    default:\n      return swe.SE_SIDM_LAHIRI;\n  }\n}\n\nexport type DateTimeInputNormalized = {\n  year: number;\n  month: number;\n  day: number;\n  hourDecimal: number;\n  calendar: 'gregorian' | 'julian';\n};\n\nexport function normalizeDateTime(input: {\n  year: number;\n  month: number;\n  day: number;\n  hour: number;\n  minute: number;\n  second?: number;\n  timezone?: string;\n  dstMinutes?: number;\n  calendar?: 'gregorian' | 'julian';\n}): DateTimeInputNormalized {\n  const second = input.second ?? 0;\n  const zone = input.timezone ?? 'UTC';\n  const dt = DateTime.fromObject(\n    {\n      year: input.year,\n      month: input.month,\n      day: input.day,\n      hour: input.hour,\n      minute: input.minute,\n      second,\n    },\n    { zone },\n  ).minus({ minutes: input.dstMinutes ?? 0 }).toUTC();\n  return {\n    year: dt.year,\n    month: dt.month,\n    day: dt.day,\n    hourDecimal: dt.hour + dt.minute / 60 + dt.second / 3600,\n    calendar: input.calendar ?? 'gregorian',\n  };\n}\n\nexport function siderealTimes(jdUt: number, lon: number) {\n  const raw = swe.swe_sidtime(jdUt) as any;\n  const gstVal = typeof raw === 'number' ? raw : raw?.siderialTime;\n  const gst = normalizeHour(gstVal ?? 0);\n  const lst = normalizeHour(gst + lon / 15);\n  return { gst, lst };\n}\n\nexport function computeBodyPosition(\n  jdUt: number,\n  body: Body,\n  opts: CalculationOptions,\n  location?: Location,\n): BodyPosition {\n  const cacheKey = `${jdUt}-${JSON.stringify(body)}-${JSON.stringify(opts)}-${location?.lat ?? ''}-${location?.lon ?? ''}`;\n  if (opts.cache && positionCache.has(cacheKey)) {\n    return positionCache.get(cacheKey)!;\n  }\n  const flags = buildFlags(opts, location);\n  const target = typeof body === 'string' ? planetMap[body] : body.asteroid;\n  const resultEcl = swe.swe_calc_ut(jdUt, target, flags) as any;\n  if (typeof resultEcl?.longitude !== 'number') {\n    throw new Error(`Swiss Ephemeris failed for ${JSON.stringify(body)}`);\n  }\n  const { longitude, latitude, distance } = {\n    longitude: resultEcl.longitude,\n    latitude: resultEcl.latitude,\n    distance: resultEcl.distance,\n  };\n  const eqFlags = flags | swe.SEFLG_EQUATORIAL;\n  const resultEq = swe.swe_calc_ut(jdUt, target, eqFlags) as any;\n  const raDeg =\n    typeof resultEq?.rectAscension === 'number'\n      ? resultEq.rectAscension\n      : typeof resultEq?.longitude === 'number'\n        ? resultEq.longitude\n        : null;\n  const decDeg =\n    typeof resultEq?.declination === 'number'\n      ? resultEq.declination\n      : typeof resultEq?.latitude === 'number'\n        ? resultEq.latitude\n        : null;\n  if (raDeg === null || decDeg === null) {\n    throw new Error(`Swiss Ephemeris equatorial output missing RA/DEC for ${JSON.stringify(body)}`);\n  }\n  const ra = raDeg / 15;\n  const dec = decDeg;\n  const position: BodyPosition = {\n    body,\n    jd: jdUt,\n    ra: normalizeHour(ra),\n    dec,\n    eclipticLon: normalizeDeg(longitude),\n    eclipticLat: latitude,\n    distanceAU: distance,\n    lst: 0,\n  };\n  if (opts.cache) positionCache.set(cacheKey, position);\n  return position;\n}\n\nexport function attachLst(position: BodyPosition, lst: number): BodyPosition {\n  return { ...position, lst: normalizeHour(lst) };\n}\n\nexport function toJulianDayUTC(dt: DateTimeInputNormalized): number {\n  const hour = Math.floor(dt.hourDecimal);\n  const minuteDecimal = (dt.hourDecimal - hour) * 60;\n  const minute = Math.floor(minuteDecimal);\n  const second = (minuteDecimal - minute) * 60;\n  const calFlag = dt.calendar === 'julian' ? swe.SE_JUL_CAL : swe.SE_GREG_CAL;\n  const res = swe.swe_utc_to_jd(dt.year, dt.month, dt.day, hour, minute, second, calFlag);\n  if ((res as any).error) {\n    throw new Error(`swe_utc_to_jd failed: ${(res as any).error}`);\n  }\n  const jdUt = (res as any).julianDayUT ?? (res as any).julday_ut ?? (res as any).julday;\n  return jdUt;\n}\n","import type { Coordinate, GeoJSONLineString, LineStrength } from './types';\n\nexport const DEG2RAD = Math.PI / 180;\nexport const RAD2DEG = 180 / Math.PI;\n\nexport function degToRad(deg: number): number {\n  return deg * DEG2RAD;\n}\n\nexport function radToDeg(rad: number): number {\n  return rad * RAD2DEG;\n}\n\nexport function normalizeDeg(deg: number): number {\n  const res = ((deg % 360) + 360) % 360;\n  return res === 360 ? 0 : res;\n}\n\nexport function normalizeHour(hours: number): number {\n  const res = ((hours % 24) + 24) % 24;\n  return res === 24 ? 0 : res;\n}\n\nexport function clampLat(lat: number): number {\n  return Math.max(-89.999, Math.min(89.999, lat));\n}\n\nexport function haversineKm(a: Coordinate, b: Coordinate): number {\n  const R = 6371; // Earth radius km\n  const dLat = degToRad(b.lat - a.lat);\n  const dLon = degToRad(b.lon - a.lon);\n  const lat1 = degToRad(a.lat);\n  const lat2 = degToRad(b.lat);\n  const h =\n    Math.sin(dLat / 2) ** 2 +\n    Math.cos(lat1) *\n      Math.cos(lat2) *\n      Math.sin(dLon / 2) ** 2;\n  return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));\n}\n\nexport function pointSegmentDistanceKm(p: Coordinate, a: Coordinate, b: Coordinate): number {\n  const R = 6371;\n  const φ1 = degToRad(a.lat);\n  const λ1 = degToRad(a.lon);\n  const φ2 = degToRad(b.lat);\n  const λ2 = degToRad(b.lon);\n  const φp = degToRad(p.lat);\n  const λp = degToRad(p.lon);\n\n  const d13 = haversineKm(a, p) / R; // in radians\n  const θ13 = bearingRad(a, p);\n  const θ12 = bearingRad(a, b);\n  const dXt = Math.asin(Math.sin(d13) * Math.sin(θ13 - θ12));\n  const dAt = Math.acos(Math.cos(d13) / Math.cos(dXt));\n  const d12 = haversineKm(a, b) / R;\n\n  let dist;\n  if (dAt < 0) {\n    dist = haversineKm(p, a);\n  } else if (dAt > d12) {\n    dist = haversineKm(p, b);\n  } else {\n    dist = Math.abs(dXt) * R;\n  }\n  return dist;\n}\n\nfunction bearingRad(a: Coordinate, b: Coordinate): number {\n  const φ1 = degToRad(a.lat);\n  const φ2 = degToRad(b.lat);\n  const Δλ = degToRad(b.lon - a.lon);\n  const y = Math.sin(Δλ) * Math.cos(φ2);\n  const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);\n  return Math.atan2(y, x);\n}\n\nexport function toGeoJSONLineString(coords: Coordinate[], properties?: Record<string, unknown>): GeoJSONLineString {\n  return {\n    type: 'Feature',\n    geometry: {\n      type: 'LineString',\n      coordinates: coords.map((c) => [normalizeLon(c.lon), c.lat]),\n    },\n    properties,\n  };\n}\n\nexport function normalizeLon(lon: number): number {\n  const res = ((lon + 180) % 360 + 360) % 360 - 180;\n  return res;\n}\n\nexport function classifyStrength(distanceKm: number, geoOrbKm: number): LineStrength {\n  if (distanceKm <= geoOrbKm * 0.33) return 'strong';\n  if (distanceKm <= geoOrbKm * 0.66) return 'medium';\n  return 'weak';\n}\n\nexport function interpolateGreatCircle(start: Coordinate, bearingDeg: number, distanceKm: number, stepKm = 50): Coordinate[] {\n  const R = 6371;\n  const brng = degToRad(bearingDeg);\n  const coords: Coordinate[] = [];\n  const steps = Math.max(2, Math.ceil(distanceKm / stepKm));\n  for (let i = 0; i <= steps; i++) {\n    const d = (distanceKm * i) / steps;\n    const angDist = d / R;\n    const lat1 = degToRad(start.lat);\n    const lon1 = degToRad(start.lon);\n    const lat2 = Math.asin(\n      Math.sin(lat1) * Math.cos(angDist) +\n        Math.cos(lat1) * Math.sin(angDist) * Math.cos(brng),\n    );\n    const lon2 =\n      lon1 +\n      Math.atan2(\n        Math.sin(brng) * Math.sin(angDist) * Math.cos(lat1),\n        Math.cos(angDist) - Math.sin(lat1) * Math.sin(lat2),\n      );\n    coords.push({ lat: radToDeg(lat2), lon: normalizeLon(radToDeg(lon2)) });\n  }\n  return coords;\n}\n","import type { ACGLinesResult, Angle, Body, CalculationOptions, CoordinateLine, Crossing, Location } from './types';\nimport { attachLst, computeBodyPosition, normalizeDateTime, siderealTimes, toJulianDayUTC } from './ephemeris';\nimport { clampLat, normalizeDeg, normalizeLon, normalizeHour, toGeoJSONLineString, radToDeg, degToRad, haversineKm } from './utils';\n\nconst VERSION = '0.1.0';\n\nexport function computeACG(\n  datetime: Parameters<typeof normalizeDateTime>[0],\n  opts: CalculationOptions,\n  bodies: Body[],\n  baseLocation?: Location,\n): ACGLinesResult {\n  const normalized = normalizeDateTime(datetime);\n  const jdUt = toJulianDayUTC(normalized);\n  if (opts.ephemerisPath) {\n    // lazy init in ephemeris module\n  }\n  const gst = siderealTimes(jdUt, 0).gst;\n  const lines: CoordinateLine[] = [];\n\n  const baseLon = baseLocation?.lon ?? 0;\n  const lstBase = siderealTimes(jdUt, baseLon).lst;\n  const positions = bodies.map((body) => {\n    const pos = computeBodyPosition(jdUt, body, opts, baseLocation);\n    return attachLst(pos, lstBase);\n  });\n\n  for (const pos of positions) {\n    lines.push(...buildAngularLines(pos, gst, opts));\n  }\n\n  const crossings = findCrossings(lines);\n\n  return {\n    timestamp: new Date().toISOString(),\n    gst,\n    bodies: positions,\n    lines,\n    crossings,\n    version: VERSION,\n    options: opts,\n  };\n}\n\nfunction buildAngularLines(pos: { ra: number; dec: number; body: Body }, gst: number, opts: CalculationOptions): CoordinateLine[] {\n  const mcLon = normalizeLon((pos.ra - gst) * 15);\n  const icLon = normalizeLon(((pos.ra + 12) - gst) * 15);\n\n  const mc: CoordinateLine = {\n    kind: 'MC',\n    body: pos.body,\n    coordinates: [\n      { lat: 89.999, lon: mcLon },\n      { lat: -89.999, lon: mcLon },\n    ],\n    geojson: toGeoJSONLineString([\n      { lat: 89.999, lon: mcLon },\n      { lat: -89.999, lon: mcLon },\n    ]),\n  };\n\n  const ic: CoordinateLine = {\n    kind: 'IC',\n    body: pos.body,\n    coordinates: [\n      { lat: 89.999, lon: icLon },\n      { lat: -89.999, lon: icLon },\n    ],\n    geojson: toGeoJSONLineString([\n      { lat: 89.999, lon: icLon },\n      { lat: -89.999, lon: icLon },\n    ]),\n  };\n\n  const ascLine = buildAscDscCurve(pos, gst, 'ASC', opts);\n  const dscLine = buildAscDscCurve(pos, gst, 'DSC', opts);\n\n  return [mc, ic, ascLine, dscLine];\n}\n\nfunction buildAscDscCurve(pos: { ra: number; dec: number; body: Body }, gst: number, angle: Angle, opts: CalculationOptions): CoordinateLine {\n  const step = opts.samplingStepDeg ?? 2; // degrees in longitude\n  const coords = [] as { lat: number; lon: number }[];\n  const altOffset = opts.refractAscDsc ? degToRad(-0.5667) : 0; // approximate refraction at horizon\n  for (let lon = -180; lon <= 180; lon += step) {\n    const lst = normalizeHour(gst + lon / 15);\n    const H = degToRad((lst - pos.ra) * 15);\n    const decRad = degToRad(pos.dec);\n    let latRad = Math.atan2(-Math.cos(H) * Math.cos(decRad), Math.sin(decRad));\n\n    if (opts.refractAscDsc) {\n      // refine latitude so that apparent altitude equals altOffset (negative)\n      latRad = solveLatitudeForAltitude(decRad, H, altOffset, latRad);\n    }\n\n    let lat = radToDeg(latRad);\n    lat = clampLat(lat);\n    const isAsc = Math.sin(H) < 0;\n    if ((angle === 'ASC' && isAsc) || (angle === 'DSC' && !isAsc)) {\n      coords.push({ lat, lon: normalizeLon(lon) });\n    }\n  }\n  // ensure continuity by sorting longitudes\n  coords.sort((a, b) => a.lon - b.lon);\n  return {\n    kind: angle,\n    body: pos.body,\n    coordinates: coords,\n    geojson: toGeoJSONLineString(coords),\n  };\n}\n\nfunction apparentAltitude(latRad: number, decRad: number, H: number): number {\n  return Math.asin(Math.sin(latRad) * Math.sin(decRad) + Math.cos(latRad) * Math.cos(decRad) * Math.cos(H));\n}\n\nfunction solveLatitudeForAltitude(decRad: number, H: number, targetAlt: number, initialLat: number): number {\n  let low = degToRad(-89.9);\n  let high = degToRad(89.9);\n  let lat = initialLat;\n  for (let i = 0; i < 12; i++) {\n    const alt = apparentAltitude(lat, decRad, H);\n    if (Math.abs(alt - targetAlt) < 1e-5) break;\n    if (alt > targetAlt) {\n      high = lat;\n    } else {\n      low = lat;\n    }\n    lat = (low + high) / 2;\n  }\n  return lat;\n}\n\nfunction segmentsIntersect(a1: { lat: number; lon: number }, a2: { lat: number; lon: number }, b1: { lat: number; lon: number }, b2: { lat: number; lon: number }) {\n  const det = (a2.lon - a1.lon) * (b2.lat - b1.lat) - (a2.lat - a1.lat) * (b2.lon - b1.lon);\n  if (Math.abs(det) < 1e-12) return null;\n  const t = ((b1.lat - a1.lat) * (b2.lon - b1.lon) - (b1.lon - a1.lon) * (b2.lat - b1.lat)) / det;\n  const u = ((b1.lat - a1.lat) * (a2.lon - a1.lon) - (b1.lon - a1.lon) * (a2.lat - a1.lat)) / det;\n  if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n    return {\n      lat: a1.lat + t * (a2.lat - a1.lat),\n      lon: a1.lon + t * (a2.lon - a1.lon),\n    };\n  }\n  return null;\n}\n\nfunction findCrossings(lines: CoordinateLine[]): Crossing[] {\n  const crossings: Crossing[] = [];\n  for (let i = 0; i < lines.length; i++) {\n    for (let j = i + 1; j < lines.length; j++) {\n      const l1 = lines[i];\n      const l2 = lines[j];\n      for (let s1 = 0; s1 < l1.coordinates.length - 1; s1++) {\n        for (let s2 = 0; s2 < l2.coordinates.length - 1; s2++) {\n          const p = segmentsIntersect(\n            l1.coordinates[s1],\n            l1.coordinates[s1 + 1],\n            l2.coordinates[s2],\n            l2.coordinates[s2 + 1],\n          );\n          if (p) {\n            const classification: 'real' | 'pseudo' = Math.abs(p.lat) > 85 ? 'pseudo' : 'real';\n            crossings.push({ at: p, lines: [l1, l2], classification });\n          } else {\n            const d = haversineKm(l1.coordinates[s1], l2.coordinates[s2]);\n            if (d < 50) {\n              crossings.push({ at: l1.coordinates[s1], lines: [l1, l2], classification: 'pseudo' });\n            }\n          }\n        }\n      }\n    }\n  }\n  return crossings;\n}\n","import type { Angle, Body, CalculationOptions, ParansResult, Paran } from './types';\nimport { computeBodyPosition, normalizeDateTime, siderealTimes, toJulianDayUTC } from './ephemeris';\nimport { degToRad, radToDeg } from './utils';\n\nconst VERSION = '0.1.0';\n\nexport function computeParans(\n  datetime: Parameters<typeof normalizeDateTime>[0],\n  opts: CalculationOptions,\n  bodies: Body[],\n  latStep = 1,\n): ParansResult {\n  const normalized = normalizeDateTime(datetime);\n  const jdUt = toJulianDayUTC(normalized);\n  const gst = siderealTimes(jdUt, 0).gst;\n\n  const positions = bodies.map((b) => computeBodyPosition(jdUt, b, opts));\n  const parans: Paran[] = [];\n\n  for (let lat = -80; lat <= 80; lat += latStep) {\n    const latRad = degToRad(lat);\n    for (let i = 0; i < positions.length; i++) {\n      for (let j = i + 1; j < positions.length; j++) {\n        const p1 = positions[i];\n        const p2 = positions[j];\n        const h1 = hourAngleForHorizon(p1.dec, latRad);\n        const h2 = hourAngleForHorizon(p2.dec, latRad);\n        if (Number.isNaN(h1) || Number.isNaN(h2)) continue;\n        const orb = Math.abs(radToDeg(h1 - h2));\n        if (orb <= (opts.angularOrbDeg ?? 1)) {\n          const angles: [Angle, Angle] = [angleFromHourAngle(h1), angleFromHourAngle(h2)];\n          parans.push({\n            latitude: lat,\n            bodies: [p1.body, p2.body],\n            angles,\n            orbDeg: orb,\n          });\n        }\n      }\n    }\n  }\n\n  return { parans, version: VERSION };\n}\n\nfunction hourAngleForHorizon(decDeg: number, latRad: number): number {\n  const decRad = degToRad(decDeg);\n  const cosH = -Math.tan(latRad) * Math.tan(decRad);\n  if (Math.abs(cosH) > 1) return Number.NaN;\n  return Math.acos(cosH);\n}\n\nfunction angleFromHourAngle(h: number): Angle {\n  // rising if H negative in time; we approximate with quadrant\n  const deg = radToDeg(h);\n  if (deg < 90) return 'ASC';\n  if (deg > 90 && deg < 180) return 'MC';\n  if (deg > 180 && deg < 270) return 'DSC';\n  return 'IC';\n}\n","import type { Body, CalculationOptions, LocalSpaceLine, LocalSpaceResult, Location } from './types';\nimport { computeBodyPosition, normalizeDateTime, siderealTimes, toJulianDayUTC } from './ephemeris';\nimport { degToRad, interpolateGreatCircle, normalizeHour, radToDeg, normalizeLon } from './utils';\n\nconst VERSION = '0.1.0';\n\nexport function computeLocalSpace(\n  datetime: Parameters<typeof normalizeDateTime>[0],\n  origin: Location,\n  opts: CalculationOptions,\n  bodies: Body[],\n): LocalSpaceResult {\n  const normalized = normalizeDateTime(datetime);\n  const jdUt = toJulianDayUTC(normalized);\n  const lst = siderealTimes(jdUt, origin.lon).lst;\n\n  const lines: LocalSpaceLine[] = [];\n  for (const body of bodies) {\n    const pos = computeBodyPosition(jdUt, body, opts, origin);\n    const az = azimuth(pos.ra, pos.dec, lst, origin.lat);\n    const coords = interpolateGreatCircle(origin, az, 20000, 100); // full great-circle\n    lines.push({ body, bearing: az, coordinates: coords });\n  }\n\n  return { origin, lines, version: VERSION };\n}\n\nfunction azimuth(raHours: number, decDeg: number, lstHours: number, latDeg: number): number {\n  const H = degToRad((lstHours - raHours) * 15);\n  const dec = degToRad(decDeg);\n  const lat = degToRad(latDeg);\n  const y = Math.sin(H);\n  const x = Math.cos(H) * Math.sin(lat) - Math.tan(dec) * Math.cos(lat);\n  let az = radToDeg(Math.atan2(y, x));\n  az = normalizeLon(az + 180); // convert to bearing from north\n  return az;\n}\n","import swe from 'swisseph';\nimport type { CalculationOptions, Location, RelocationChartResult } from './types';\nimport { normalizeDateTime, siderealTimes, toJulianDayUTC } from './ephemeris';\n\nconst VERSION = '0.1.0';\n\nconst systems: Record<string, string> = {\n  placidus: 'P',\n  koch: 'K',\n  equal: 'E',\n  wholesign: 'W',\n};\n\nexport function computeRelocationChart(\n  datetime: Parameters<typeof normalizeDateTime>[0],\n  location: Location,\n  opts: CalculationOptions,\n): RelocationChartResult {\n  const normalized = normalizeDateTime(datetime);\n  const jdUt = toJulianDayUTC(normalized);\n  const angles = computeAngles(jdUt, location, opts);\n  const houses: Record<string, number[]> = {};\n\n  for (const [name, code] of Object.entries(systems)) {\n    const res = swe.swe_houses_ex(jdUt, swe.SEFLG_SPEED, location.lat, location.lon, code) as any;\n    if (res && Array.isArray(res.house)) {\n      houses[name] = res.house;\n    } else {\n      houses[name] = [];\n    }\n  }\n\n  return { location, houses, angles, version: VERSION };\n}\n\nfunction computeAngles(jdUt: number, location: Location, opts: CalculationOptions) {\n  const st = siderealTimes(jdUt, location.lon);\n  const res = swe.swe_houses_ex(jdUt, swe.SEFLG_SPEED, location.lat, location.lon, 'P') as any;\n  const asc = res?.ascendant ?? 0;\n  const mc = res?.mc ?? 0;\n  const armc = res?.armc ?? 0;\n  const vertex = res?.vertex ?? 0;\n  const equasc = res?.equatorialAscendant ?? 0;\n  return {\n    ASC: asc,\n    MC: mc,\n    IC: (mc + 180) % 360,\n    DSC: (asc + 180) % 360,\n    ARM: armc,\n    vertex,\n    equasc,\n    lst: st.lst,\n  } as Record<'ASC' | 'MC' | 'IC' | 'DSC', number> & Record<string, number>;\n}\n","import type {\n  ACGLinesResult,\n  Angle,\n  Body,\n  CalculationOptions,\n  Location,\n  LocationAnalysisItem,\n  LocationAnalysisResult,\n  Paran,\n} from './types';\nimport { classifyStrength, haversineKm, pointSegmentDistanceKm } from './utils';\n\nconst VERSION = '0.1.0';\n\nexport function analyzeLocation(\n  city: Location,\n  radiusKm: number,\n  acg: ACGLinesResult,\n  parans: Paran[],\n  opts: CalculationOptions,\n): LocationAnalysisResult {\n  const geoOrb = opts.geoOrbKm ?? 300;\n  const active: LocationAnalysisItem[] = [];\n\n  for (const line of acg.lines) {\n    const closest = minDistanceToLine(city, line.coordinates);\n    if (closest <= radiusKm) {\n      const strength = classifyStrength(closest, geoOrb);\n      const force = Math.exp(-closest / geoOrb);\n      active.push({ body: line.body, angle: line.kind as Angle, distanceKm: closest, strength, force });\n    }\n  }\n\n  const ranking = [...active].sort(\n    (a, b) => compositeWeight(b) - compositeWeight(a),\n  );\n  const paransInArea = parans.filter((p) => Math.abs(p.latitude - city.lat) <= radiusKm / 111);\n\n  return { city, radiusKm, active, parans: paransInArea, ranking, version: VERSION };\n}\n\nfunction minDistanceToLine(point: Location, coords: { lat: number; lon: number }[]): number {\n  if (coords.length === 0) return Number.POSITIVE_INFINITY;\n  if (coords.length === 1) return haversineKm(point, coords[0]);\n  let min = Number.POSITIVE_INFINITY;\n  for (let i = 0; i < coords.length - 1; i++) {\n    const d = pointSegmentDistanceKm(point, coords[i], coords[i + 1]);\n    if (d < min) min = d;\n  }\n  return min;\n}\n\nfunction strengthWeight(s: ReturnType<typeof classifyStrength>): number {\n  switch (s) {\n    case 'strong':\n      return 3;\n    case 'medium':\n      return 2;\n    default:\n      return 1;\n  }\n}\n\nfunction anglePriority(angle: Angle): number {\n  if (angle === 'MC' || angle === 'ASC') return 2;\n  return 1;\n}\n\nfunction compositeWeight(item: LocationAnalysisItem): number {\n  return strengthWeight(item.strength) * anglePriority(item.angle) * bodyPriority(item.body) * item.force;\n}\n\nfunction bodyPriority(body: Body): number {\n  if (typeof body !== 'string') return 1;\n  const personal = ['sun', 'moon', 'mercury', 'venus', 'mars'];\n  const social = ['jupiter', 'saturn'];\n  if (personal.includes(body)) return 1.3;\n  if (social.includes(body)) return 1.1;\n  return 1.0;\n}\n","import { z } from 'zod';\n\nexport const CoordinateSchema = z.object({ lat: z.number(), lon: z.number() });\n\nexport const BodySchema = z.union([\n  z.literal('sun'),\n  z.literal('moon'),\n  z.literal('mercury'),\n  z.literal('venus'),\n  z.literal('mars'),\n  z.literal('jupiter'),\n  z.literal('saturn'),\n  z.literal('uranus'),\n  z.literal('neptune'),\n  z.literal('pluto'),\n  z.literal('true_node'),\n  z.literal('mean_node'),\n  z.literal('chiron'),\n  z.literal('fortune'),\n  z.object({ asteroid: z.number(), name: z.string().optional() }),\n]);\n\nexport const BodyPositionSchema = z.object({\n  body: BodySchema,\n  jd: z.number(),\n  ra: z.number(),\n  dec: z.number(),\n  eclipticLon: z.number(),\n  eclipticLat: z.number(),\n  distanceAU: z.number(),\n  lst: z.number(),\n});\n\nexport const CoordinateLineSchema = z.object({\n  kind: z.enum(['MC', 'IC', 'ASC', 'DSC', 'LOCAL_SPACE', 'CROSSING']),\n  body: BodySchema,\n  coordinates: z.array(CoordinateSchema),\n  geojson: z\n    .object({\n      type: z.literal('Feature'),\n      geometry: z.object({ type: z.literal('LineString'), coordinates: z.array(z.tuple([z.number(), z.number()])) }),\n      properties: z.record(z.unknown()).optional(),\n    })\n    .optional(),\n  strength: z.enum(['strong', 'medium', 'weak']).optional(),\n  metadata: z.record(z.unknown()).optional(),\n});\n\nexport const CrossingSchema = z.object({\n  at: CoordinateSchema,\n  lines: z.tuple([CoordinateLineSchema, CoordinateLineSchema]),\n  classification: z.enum(['real', 'pseudo']),\n});\n\nexport const ACGLinesResultSchema = z.object({\n  timestamp: z.string(),\n  gst: z.number(),\n  bodies: z.array(BodyPositionSchema),\n  lines: z.array(CoordinateLineSchema),\n  crossings: z.array(CrossingSchema),\n  version: z.string(),\n  options: z.record(z.unknown()),\n});\n\nexport const ParanSchema = z.object({\n  latitude: z.number(),\n  bodies: z.tuple([BodySchema, BodySchema]),\n  angles: z.tuple([z.enum(['MC', 'IC', 'ASC', 'DSC']), z.enum(['MC', 'IC', 'ASC', 'DSC'])]),\n  orbDeg: z.number(),\n});\n\nexport const ParansResultSchema = z.object({ parans: z.array(ParanSchema), version: z.string() });\n\nexport const LocalSpaceLineSchema = z.object({\n  body: BodySchema,\n  bearing: z.number(),\n  coordinates: z.array(CoordinateSchema),\n});\n\nexport const LocalSpaceResultSchema = z.object({\n  origin: CoordinateSchema.extend({ alt: z.number().optional() }),\n  lines: z.array(LocalSpaceLineSchema),\n  version: z.string(),\n});\n\nexport const LocationAnalysisItemSchema = z.object({\n  body: BodySchema,\n  angle: z.enum(['MC', 'IC', 'ASC', 'DSC']),\n  distanceKm: z.number(),\n  strength: z.enum(['strong', 'medium', 'weak']),\n  force: z.number(),\n});\n\nexport const LocationAnalysisResultSchema = z.object({\n  city: CoordinateSchema.extend({ alt: z.number().optional() }),\n  radiusKm: z.number(),\n  active: z.array(LocationAnalysisItemSchema),\n  parans: z.array(ParanSchema),\n  ranking: z.array(LocationAnalysisItemSchema),\n  version: z.string(),\n});\n\nexport const RelocationChartResultSchema = z.object({\n  location: CoordinateSchema.extend({ alt: z.number().optional() }),\n  houses: z.record(z.array(z.number())),\n  angles: z.record(z.number()),\n  version: z.string(),\n});\n\nexport const Schemas = {\n  ACGLinesResultSchema,\n  ParansResultSchema,\n  LocalSpaceResultSchema,\n  LocationAnalysisResultSchema,\n  RelocationChartResultSchema,\n};\n\nexport type Schemas = typeof Schemas;\n"],"mappings":"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","names":["swe","VERSION","VERSION","import_swisseph","VERSION","swe","VERSION"]}